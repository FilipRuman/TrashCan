// INFO: For memory allocation: 
//To find if memory is allocated do: use hash function- it will be a simple thing like juts multiply the addr by some value and then mod the output by the size of hashmap. 
// that way you get a index in array, than you can check if addr of this thing is good, if not look to the child node. if nothing matches this addr is fre.
// this will be useful for defragmentation 

struct HeapBlock{
	next: &HeapBlock,
}


fn core_deallocate(addr:u32,size_raw: u32){
	let size_log2= ceil_log2(size_raw);
	let min = access_static("min_heap_size_pow_2");
	let size_to_free_log2 = max(min,size_log2) -min;
	let size = 2 << (size_to_free_log2 + min - 1);

	let current_head_of_needed_list = access_static("free_heap_blocks_linked_lists")[size_to_free_log2];
	let addr_of_current_head = *access_reference(current_head_of_needed_list);
	//print_raw(addr_of_current_head);
		
	let new_heap_block = HeapBlock[next = (addr_of_current_head as &HeapBlock)];

	// write HeapBlock into memory 
	mem(addr) = addr_of_current_head;

	// addr as &HeapBlock
	access_reference(access_static("free_heap_blocks_linked_lists")[size_to_free_log2]) = addr  ; 
	
	//print_raw(addr);
	return ;
}


fn core_allocate(size: u32)-> u32{

	//print_raw(66);
	//print_raw(size);

	let size_log2= ceil_log2(size) ;

	let min = access_static("min_heap_size_pow_2");
	let max = access_static("max_heap_size_pow_2");


	if size_log2 > max {
      		panic("tried to allocate memory with size that exceeded max limit");
	}
	let size_index = max(min,size_log2) -min;

	let block_to_allocate = access_static("free_heap_blocks_linked_lists")[size_index];
	let addr = *access_reference(block_to_allocate) ;
	if  addr == 0{
		addr = allocate_new_block_of_memory_from_main_pool(size_index);	
	}else{
		let next_addr : u32 = mem(addr);
	//	print_raw(next_addr);
		let head = access_static("free_heap_blocks_linked_lists")[size_index];
		access_static("free_heap_blocks_linked_lists")[size_index] = block_to_allocate.next ;
	}
	//print_raw(addr);

	//print_raw(661);

	return addr;
}
// outputs address of this block (u32)
fn allocate_new_block_of_memory_from_main_pool(size_index: u32 )->u32{
	let size = 2 << (size_index+  access_static("min_heap_size_pow_2")  - 1);
	let heap_pool_head = access_static("heap_main_pool_head");
	let output = *heap_pool_head;

	access_static("heap_main_pool_head") += (*size) ;

	if heap_pool_head >  access_static("heap_end"){
		panic("application has overflowed it's heap!");
	}
	return output;
}

fn max(a:u32, b:u32) ->u32{
    let mask : u32= !(a > b) as u32;      // 0xFFFFFFFF if a<b else 0
    return (a && !mask) || (b && mask);
}

fn ceil_log2(x: u32) -> u32 {
	let i = 0;
	let pow_2 = 1;
	while pow_2 < x {
		pow_2 = pow_2 << 1; 
		i += 1;       
	}
	return i;
}

